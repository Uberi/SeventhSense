/*
Anthony Zhang
Seventh Sense controller source code for PIC18F14K22 microcontrollers compiling with MikroC.
*/

/*
Functionality
-------------

1. Set up the microcontroller.
2. Start timer at 1 second interval:
    1. Initialize magnetometer if not already done.
    2. Take a reading from the magnetometer.
    3. Vibrate the right motor to notify the user.
*/

// motor pins are allocated based on physical location from left to right, top to bottom if the VDD side is facing upwards
#define MOTOR1 RC7_bit
#define MOTOR2 RC6_bit
#define MOTOR3 RC3_bit
#define MOTOR4 RC4_bit
#define MOTOR5 RC5_bit
#define MOTOR6 RC2_bit
#define MOTOR7 RC1_bit
#define MOTOR8 RC0_bit

#define MAGNETOMETER_WRITE 0x3C
#define MAGNETOMETER_READ 0x3D

#define MAGNETOMETER_OVERFLOW (-4096)

#define TRIG_SCALE (long)10000 // big number used to scale fixed point calculations
#define TAN_22_5 (long)4142 // TRIG_SCALE * tan(22.5 deg)

#define NORTH 1
#define NORTHEAST 2
#define EAST 3
#define SOUTHEAST 4
#define SOUTH 5
#define SOUTHWEST 6
#define WEST 7
#define NORTHWEST 8
#define NO_DIRECTION 0

int magnetic_x = 0;
int magnetic_y = 0;
int magnetic_z = 0;

void init_magnetometer() {
    TRISB = 0x00; // PORTB as output (required for I2C to work)
    PORTB = 0x00; // initialize PORTB to 0 for I2C

    I2C1_Init(100000); // start the I2C communication channel in standard mode (100 kbps)
    
    I2C1_Start();
    I2C1_Wr(MAGNETOMETER_WRITE); // write to magnetometer
    I2C1_Wr(0x00); // write to configuration A register
    I2C1_Wr(0b01110000); // average 8 samples
    I2C1_Stop();
}

//Timer1
//Prescaler 1:8; TMR1 Preload = 18661; Actual Interrupt Time : 1.5 s

//Generated by MikroC Timer Calculator
void init_timer1() {
    T1CON = 0x31;
    TMR1IF_bit = 0;
    TMR1H = 0x48;
    TMR1L = 0xE5;
    TMR1IE_bit = 1;
    INTCON = 0xC0;
}

void main() {
    CM1CON0 = CM2CON0 = 0b111; // comparator configuration
    ANSEL = ANSELH = 0; // use digital I/O
    IDLEN_bit = 1; // enable Idle mode when sleeping (timer1 only works in normal and idle mode)

    TRISC = 0x00; // PORTC as output
    MOTOR1 = MOTOR2 = MOTOR3 = MOTOR4 = MOTOR5 = MOTOR6 = 0; // reset port state

    init_timer1(); // configure timer1 to run every second

    asm sleep; // go into idle mode, later to be woken up by timer1
}

void get_magnetometer(int *x, int *y, int *z) {
    // tell the magnetometer to make a reading
    I2C1_Start();
    I2C1_Wr(MAGNETOMETER_WRITE); // write to magnetometer
    I2C1_Wr(0x02); // write to mode register
    I2C1_Wr(0b00000001); // single measurement mode
    I2C1_Stop();

    delay_ms(150); // wait for the magnetometer to make a reading

    // read the magnetometer reading
    I2C1_Start();
    I2C1_Wr(MAGNETOMETER_READ); // read from magnetometer
    *x = (I2C1_Rd(1) << 8) | I2C1_Rd(1);
    *z = (I2C1_Rd(1) << 8) | I2C1_Rd(1);
    *y = (I2C1_Rd(1) << 8) | I2C1_Rd(0); // we always NACK the last value to indicate that we are done reading
    I2C1_Stop();
}

void notify(int index) {
    switch (index) {
        case 1: MOTOR1 = 1; break;
        case 2: MOTOR2 = 1; break;
        case 3: MOTOR3 = 1; break;
        case 4: MOTOR4 = 1; break;
        case 5: MOTOR5 = 1; break;
        case 6: MOTOR6 = 1; break;
        case 7: MOTOR7 = 1; break;
        case 8: MOTOR8 = 1; break;
    }
    delay_ms(200);
    switch (index) {
        case 1: MOTOR1 = 0; break;
        case 2: MOTOR2 = 0; break;
        case 3: MOTOR3 = 0; break;
        case 4: MOTOR4 = 0; break;
        case 5: MOTOR5 = 0; break;
        case 6: MOTOR6 = 0; break;
        case 7: MOTOR7 = 0; break;
        case 8: MOTOR8 = 0; break;
    }
}

static long axis_x, axis_y;
char get_direction(int x, int y, int z) {
    // handle overflow values
    if (x == MAGNETOMETER_OVERFLOW
     || y == MAGNETOMETER_OVERFLOW
     || z == MAGNETOMETER_OVERFLOW)
        return NO_DIRECTION; // unknown index

    axis_x = (long)x;
    axis_y = (long)y;

    // handle edge cases
    if (axis_x == 0 && axis_y == 0) // no angle
        return NO_DIRECTION;
    if (axis_x == 0)
        return y < 0 ? SOUTH : NORTH;
    if (axis_y == 0)
        return x < 0 ? WEST : EAST;

    // handle the cases in between the extremes
    if (axis_x > 0 && axis_y > 0) { // first quadrant
        if (axis_y * TRIG_SCALE < axis_x * TAN_22_5) // angle less than 22.5 degrees
            return EAST;
        if (axis_x * TRIG_SCALE < axis_y * TAN_22_5) // angle more than 90 - 22.5 degrees
            return NORTH;
        return NORTHEAST;
    }
    if (axis_x < 0 && axis_y > 0) { // second quadrant
        if (axis_y * TRIG_SCALE < -axis_x * TAN_22_5) // angle less than 90 + 22.5 degrees
            return WEST;
        if (-axis_x * TRIG_SCALE < axis_y * TAN_22_5) // angle more than 180 - 22.5 degrees
            return NORTH;
        return NORTHWEST;
    }
    if (axis_x < 0 && axis_y < 0) { // third quadrant
        if (-axis_y * TRIG_SCALE < -axis_x * TAN_22_5) // angle less than 180 + 22.5 degrees
            return WEST;
        if (-axis_x * TRIG_SCALE < -axis_y * TAN_22_5) // angle more than 270 - 22.5 degrees
            return SOUTH;
        return SOUTHWEST;
    }
    // fourth quadrant
    if (-axis_y * TRIG_SCALE < axis_x * TAN_22_5) // angle less than 270 + 22.5 degrees
        return EAST;
    if (axis_x * TRIG_SCALE < -axis_y * TAN_22_5) // angle more than 360 - 22.5 degrees
        return SOUTH;
    return SOUTHEAST;
}

static char magnetometer_uninitialized = 1; // 1 if magnetometer is still yet to be initialized, 0 if already initialized
void interrupt(){
    if (TMR1IF_bit){
        // reset timer
        TMR1IF_bit = 0;
        TMR1H = 0x48;
        TMR1L = 0xE5;

        if (magnetometer_uninitialized) {
            init_magnetometer(); // configure magnetometer to take readings every second
            magnetometer_uninitialized = 0;
        }
        else {
            get_magnetometer(&magnetic_x, &magnetic_y, &magnetic_z);
            notify(get_direction(magnetic_x, magnetic_y, magnetic_z));
        }
    }
}